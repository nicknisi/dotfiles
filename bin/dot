#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  tput cnorm # enable cursor
  # script cleanup here
}

command_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

if [[ -f "$DOTFILES/bin/lib/common.sh" ]]; then
  source "$DOTFILES/bin/lib/common.sh"
else
  echo "Error: Unable to source common.sh"
  exit 1
fi

find_commands() {
  IFS=: read -ra path_dirs <<<"$PATH"
  for dir in "${path_dirs[@]}"; do
    # skip if the directory doesn't exist or isn't readable
    [[ ! -d "$dir" ]] && continue
    for cmd in "$dir"/dot-*; do
      [[ -f "$cmd" && -x "$cmd" ]] || continue
      basename "$cmd" | sed 's/^dot-//'
    done
  done | sort -u
}

usage() {
  cat <<EOF
  $(fmt_key "Usage:") $(fmt_cmd "$command_name") $(fmt_value "<command> [subcommand] [options]")

Dotfiles management script using GNU Stow.

$(fmt_key "Available Commands:")
    help                          Show this help message
    clean                         Clean up broken symlinks
    backup                        Backup dotfiles
        -d, --directory <dir>   Backup directory (default: ~/dotfiles-backup)
    link                          Link dotfiles using GNU Stow
        -v, --verbose             Show detailed output
        -n, --dry-run             Show what would be done without doing it
    unlink                        Unlink dotfiles using GNU Stow
        -v, --verbose             Show detailed output
        -n, --dry-run             Show what would be done without doing it
    restow                        Restow dotfiles (useful after updates)
        -v, --verbose             Show detailed output
EOF

  echo -e "\nExternal commands:"

  find_commands | while read -r cmd; do
    # Get the description from the script if available
    description=$(grep "^# Description:" "$(which "dot-$cmd")" 2>/dev/null | cut -d: -f2- | sed 's/^[[:space:]]*//' || echo "No description available")
    printf "    $(fmt_cmd "%-12s") %s\n" "$cmd" "$description"
  done
}

cmd_clean() {
  fmt_title_underline "Cleaning up broken symlinks..."

  local broken_count=0

  # Check config directory symlinks
  if [ -d "$CONFIG_HOME" ]; then
    while IFS= read -r -d '' link; do
      if [ -L "$link" ] && [ ! -e "$link" ]; then
        broken_count=$((broken_count + 1))
        log_info "Removing broken symlink: ~${link#"$HOME"}"
        rm "$link"
      fi
    done < <(find "$CONFIG_HOME" -type l -print0 2>/dev/null || true)
  fi

  # Check home directory for broken symlinks
  while IFS= read -r -d '' link; do
    if [ -L "$link" ] && [ ! -e "$link" ]; then
      # Check if this broken symlink points to our dotfiles directory
      local link_target=$(readlink "$link" 2>/dev/null || echo "")
      if [[ "$link_target" == "$DOTFILES"* ]]; then
        broken_count=$((broken_count + 1))
        log_info "Removing broken symlink: ~${link#"$HOME"}"
        rm "$link"
      fi
    fi
  done < <(find "$HOME" -maxdepth 3 -type l -print0 2>/dev/null || true)

  echo
  if [ "$broken_count" -eq 0 ]; then
    log_success "No broken symlinks found"
  else
    log_success "Removed $broken_count broken symlink(s)"
  fi
}

cmd_backup() {
  local backup_dir="$HOME/dotfiles-backup"
  local verbose=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -d | --directory)
      if [[ -n "${2:-}" ]]; then
        backup_dir="$2"
        shift 2
      else
        log_error "Missing backup directory"
        exit 1
      fi
      ;;
    -v | --verbose)
      verbose=true
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      exit 1
      ;;
    esac
  done

  # Expand ~ in backup_dir
  backup_dir="${backup_dir/#\~/$HOME}"

  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="${backup_dir}/dotfiles_backup_${timestamp}"

  log_info "Creating backup in: $backup_path"

  # Find all files that would be stowed
  local files_to_backup=()
  if [ -d "$DOTFILES/home" ]; then
    while IFS= read -r -d '' file; do
      relative_path="${file#"$DOTFILES"/home/}"
      files_to_backup+=("$relative_path")
    done < <(find "$DOTFILES/home" -type f -print0)
  fi

  tmpfile=$(mktemp)
  trap 'rm -f "$tmpfile"' EXIT

  for file in "${files_to_backup[@]}"; do
    src_path="${HOME}/${file}"
    if [[ -L "$src_path" ]]; then
      [[ "$verbose" == true ]] && log_info "Skipping symlink: $file"
      continue
    elif [[ -e "$src_path" ]]; then
      echo "$file" >>"$tmpfile"
      [[ "$verbose" == true ]] && log_info "Found: $file"
    else
      log_warning "File not found: $src_path"
    fi
  done

  if [[ -s "$tmpfile" ]]; then
    tar -czf "${backup_path}.tar.gz" -C "$HOME" -T "$tmpfile" || {
      log_error "Failed to create backup archive"
      exit 1
    }

    if [[ "$verbose" == true ]]; then
      log_info "Archive contents:"
      tar -tvf "${backup_path}.tar.gz" | while read -r line; do
        log_info "$line"
      done
    fi

    log_success "Backup created successfully"
  else
    log_warning "No files to backup"
  fi
}

cmd_link() {
  local verbose=false
  local dry_run=false
  local stow_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -v | --verbose)
      verbose=true
      stow_args+=("--verbose")
      shift
      ;;
    -n | --dry-run)
      dry_run=true
      stow_args+=("--no")
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      exit 1
      ;;
    esac
  done

  fmt_title_underline "Linking dotfiles with GNU Stow"

  # Check if stow is installed
  if ! command -v stow >/dev/null 2>&1; then
    log_error "GNU Stow is not installed. Please install it first:"
    log_error "  macOS: brew install stow"
    log_error "  Linux: apt-get install stow or yum install stow"
    exit 1
  fi

  # Use stow to link the home package
  if [ -d "$DOTFILES/home" ]; then
    [[ "$verbose" == true ]] && log_info "Running: stow --target=$HOME --dir=$DOTFILES ${stow_args[*]:-} home"

    if stow --target="$HOME" --dir="$DOTFILES" "${stow_args[@]}" home 2>&1; then
      echo
      if [ "$dry_run" == true ]; then
        log_success "Dry run completed. No changes were made."
      else
        log_success "Dotfiles linked successfully"
      fi
    else
      echo
      log_error "Failed to stow dotfiles. You may need to:"
      log_error "  1. Back up existing files: dot backup"
      log_error "  2. Remove conflicting files manually"
      log_error "  3. Run with --verbose to see what's conflicting"
      exit 1
    fi
  else
    log_error "Home package not found at $DOTFILES/home"
    exit 1
  fi
}

cmd_unlink() {
  local verbose=false
  local dry_run=false
  local stow_args=("--delete")

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -v | --verbose)
      verbose=true
      stow_args+=("--verbose")
      shift
      ;;
    -n | --dry-run)
      dry_run=true
      stow_args+=("--no")
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      exit 1
      ;;
    esac
  done

  fmt_title_underline "Unlinking dotfiles with GNU Stow"

  # Check if stow is installed
  if ! command -v stow >/dev/null 2>&1; then
    log_error "GNU Stow is not installed"
    exit 1
  fi

  # Use stow to unlink the home package
  if [ -d "$DOTFILES/home" ]; then
    [[ "$verbose" == true ]] && log_info "Running: stow --target=$HOME --dir=$DOTFILES ${stow_args[*]} home"

    if stow --target="$HOME" --dir="$DOTFILES" "${stow_args[@]}" home 2>&1; then
      echo
      if [ "$dry_run" == true ]; then
        log_success "Dry run completed. No changes were made."
      else
        log_success "Dotfiles unlinked successfully"
      fi
    else
      echo
      log_error "Failed to unstow dotfiles"
      exit 1
    fi
  else
    log_error "Home package not found at $DOTFILES/home"
    exit 1
  fi
}

cmd_restow() {
  local verbose=false
  local stow_args=("--restow")

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -v | --verbose)
      verbose=true
      stow_args+=("--verbose")
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      exit 1
      ;;
    esac
  done

  fmt_title_underline "Restowing dotfiles with GNU Stow"

  # Check if stow is installed
  if ! command -v stow >/dev/null 2>&1; then
    log_error "GNU Stow is not installed"
    exit 1
  fi

  # Use stow to restow the home package
  if [ -d "$DOTFILES/home" ]; then
    [[ "$verbose" == true ]] && log_info "Running: stow --target=$HOME --dir=$DOTFILES ${stow_args[*]} home"

    if stow --target="$HOME" --dir="$DOTFILES" "${stow_args[@]}" home 2>&1; then
      echo
      log_success "Dotfiles restowed successfully"
    else
      echo
      log_error "Failed to restow dotfiles"
      exit 1
    fi
  else
    log_error "Home package not found at $DOTFILES/home"
    exit 1
  fi
}

main() {
  if [ $# -lt 1 ]; then
    usage
    exit 0
  fi

  cmd="$1"
  shift || true

  case "$cmd" in
  help)
    usage
    ;;
  clean)
    cmd_clean "$@"
    ;;
  backup)
    cmd_backup "$@"
    ;;
  link)
    cmd_link "$@"
    ;;
  unlink)
    cmd_unlink "$@"
    ;;
  restow)
    cmd_restow "$@"
    ;;
  *)
    if command -v "dot-$cmd" >/dev/null 2>&1; then
      "dot-$cmd" "$@"
    else
      log_error "Unknown command: $cmd"
      usage
      exit 1
    fi
    ;;
  esac
}

main "$@"
